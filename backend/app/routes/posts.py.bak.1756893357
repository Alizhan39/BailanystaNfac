from __future__ import annotations
from datetime import datetime
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity, verify_jwt_in_request
from sqlalchemy import and_, or_, func
from ..db import db
from ..models import Post, User, Like, Comment
bp = Blueprint("posts", __name__, url_prefix="/api/posts")

def _serialize_post(p, like_counts, current_user_id=None):
    liked_by_me = False
    if current_user_id:
        liked_by_me = bool(Like.query.filter_by(user_id=current_user_id, post_id=p.id).first())
comments_count = db.session.execute(
        db.select(func.count(Comment.id)).where(Comment.post_id == p.id)
    ).scalar_one()
    return {
        "id": p.id,
        "text": p.text,
        "created_at": p.created_at.isoformat(),
        "author": {
            "id": p.author.id,
            "username": p.author.username,
            "created_at": p.author.created_at.isoformat(),
        },
        "likes": int(like_counts.get(p.id, 0)),
        "liked_by_me": liked_by_me,
        "comments_count": int(comments_count),
    }

@bp.get("")
def list_posts():
current_user_id = None
    try:
        verify_jwt_in_request(optional=True)
        uid = get_jwt_identity()
        if uid is not None:
            current_user_id = int(uid)
    except Exception:
        pass

    cursor = request.args.get("cursor")
    limit = min(int(request.args.get("limit", 20)), 50)

    q = Post.query
    if cursor:
        try:
            ts_s, id_s = cursor.split("|")
            ts = datetime.fromisoformat(ts_s)
            q = q.filter(
                or_(
                    Post.created_at < ts,
                    and_(Post.created_at == ts, Post.id < int(id_s)),
                )
            )
        except Exception:
            return jsonify({"error": "bad cursor"}), 400

    items = q.order_by(Post.created_at.desc(), Post.id.desc()).limit(limit + 1).all()

    next_cursor = None
    if len(items) > limit:
        last = items[limit - 1]
        next_cursor = f"{last.created_at.isoformat()}|{last.id}"
        items = items[:limit]

    like_counts = {}
    if items:
        post_ids = [p.id for p in items]
        rows = db.session.execute(
            db.select(Like.post_id, func.count(Like.id))
            .where(Like.post_id.in_(post_ids))
            .group_by(Like.post_id)
        ).all()
        for pid, cnt in rows:
            like_counts[int(pid)] = int(cnt)

    return jsonify({
        "items": [_serialize_post(p, like_counts, current_user_id) for p in items],
        "next_cursor": next_cursor
    })

@bp.post("")
@jwt_required()
def create_post():
    uid = int(get_jwt_identity())
    user = User.query.get_or_404(uid)
    payload = request.get_json(force=True) or {}
    text = (payload.get("text") or "").strip()
    if not text:
        return jsonify({"error": "text required"}), 400
    if len(text) > 1000:
        return jsonify({"error": "text too long (1000 chars max)"}), 413
    post = Post(user_id=user.id, text=text)
    db.session.add(post)
    db.session.commit()
    return jsonify(_serialize_post(post, {}, uid)), 201

@bp.get("/<int:post_id>")
def get_post(post_id: int):
    current_user_id = None
    try:
        verify_jwt_in_request(optional=True)
        uid = get_jwt_identity()
        if uid is not None:
            current_user_id = int(uid)
    except Exception:
        pass
    post = Post.query.get_or_404(post_id)
    rows = db.session.execute(
        db.select(Like.post_id, func.count(Like.id))
        .where(Like.post_id == post.id)
        .group_by(Like.post_id)
    ).all()
    like_counts = {int(pid): int(cnt) for pid, cnt in rows}
    return jsonify(_serialize_post(post, like_counts, current_user_id))

@bp.patch("/<int:post_id>")
@jwt_required()
def edit_post(post_id: int):
    uid = int(get_jwt_identity())
    post = Post.query.get_or_404(post_id)
    if post.user_id != uid:
        return jsonify({"error": "forbidden"}), 403
    payload = request.get_json(force=True) or {}
    text = (payload.get("text") or "").strip()
    if not text:
        return jsonify({"error": "text required"}), 400
    if len(text) > 1000:
        return jsonify({"error": "text too long (1000)"}), 413
    post.text = text
    db.session.commit()
    return jsonify({"ok": True})

@bp.delete("/<int:post_id>")
@jwt_required()
def delete_post(post_id: int):
    uid = int(get_jwt_identity())
    post = Post.query.get_or_404(post_id)
    if post.user_id != uid:
        return jsonify({"error": "forbidden"}), 403
    db.session.delete(post)
    db.session.commit()
    return jsonify({"ok": True})

@bp.post("/<int:post_id>/like")
@jwt_required()
def like_post(post_id: int):
    uid = int(get_jwt_identity())
    if not Post.query.get(post_id):
        return jsonify({"error": "not found"}), 404
    exists = Like.query.filter_by(user_id=uid, post_id=post_id).first()
    if not exists:
        db.session.add(Like(user_id=uid, post_id=post_id))
        db.session.commit()
    return jsonify({"ok": True}), 201

@bp.delete("/<int:post_id>/like")
@jwt_required()
def unlike_post(post_id: int):
    uid = int(get_jwt_identity())
    like = Like.query.filter_by(user_id=uid, post_id=post_id).first()
    if like:
        db.session.delete(like)
        db.session.commit()
    return jsonify({"ok": True})

@bp.get("/<int:post_id>/comments")
def list_comments(post_id: int):
    Post.query.get_or_404(post_id)
    items = db.session.execute(
        db.select(Comment)
        .where(Comment.post_id == post_id)
        .order_by(Comment.created_at.asc())
    ).scalars().all()
    return jsonify([{
        "id": c.id,
        "text": c.text,
        "created_at": c.created_at.isoformat(),
        "author": {"id": c.user.id, "username": c.user.username, "created_at": c.user.created_at.isoformat()},
    } for c in items])

@bp.post("/<int:post_id>/comments")
@jwt_required()
def create_comment(post_id: int):
    uid = int(get_jwt_identity())
    Post.query.get_or_404(post_id)
    payload = request.get_json(force=True) or {}
    text = (payload.get("text") or "").strip()
    if not text:
        return jsonify({"error": "text required"}), 400
    if len(text) > 500:
        return jsonify({"error": "text too long (500)"}), 413
    c = Comment(user_id=uid, post_id=post_id, text=text)
    db.session.add(c)
    db.session.commit()
    return jsonify({"id": c.id}), 201

@bp.delete("/<int:post_id>/comments/<int:cid>")
@jwt_required()
def delete_comment(post_id: int, cid: int):
    uid = int(get_jwt_identity())
    c = Comment.query.get_or_404(cid)
    if c.post_id != post_id:
        return jsonify({"error": "not found"}), 404
    if c.user_id != uid:
        return jsonify({"error": "forbidden"}), 403
    db.session.delete(c)
    db.session.commit()
    return jsonify({"ok": True})
