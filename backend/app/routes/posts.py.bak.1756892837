from __future__ import annotations
from datetime import datetime
from flask import Blueprint, jsonify, request
from flask_jwt_extended import jwt_required, get_jwt_identity, verify_jwt_in_request
from sqlalchemy import and_, or_, func
from ..db import db
from ..models import Post, User, Like

bp = Blueprint("posts", __name__, url_prefix="/api/posts")

def\ _serialize_post\(p\:\ Post\,\ like_counts\:\ dict\[int\,int\]\,\ current_user_id\:\ int\ \|\ None\ \=\ None\)\:\
\ \ \ \ liked_by_me\ \=\ False\
\ \ \ \ if\ current_user_id\:\
\ \ \ \ \ \ \ \ liked_by_me\ \=\ bool\(Like\.query\.filter_by\(user_id\=current_user_id\,\ post_id\=p\.id\)\.first\(\)\)\
\ \ \ \ \#\ comments_count\
\ \ \ \ cc\ \=\ db\.session\.execute\(\
\ \ \ \ \ \ \ \ db\.select\(func\.count\(Comment\.id\)\)\.where\(Comment\.post_id\ \=\=\ p\.id\)\
\ \ \ \ \)\.scalar_one\(\)\
\ \ \ \ return\ \{\
\ \ \ \ \ \ \ \ \"id\"\:\ p\.id\,\
\ \ \ \ \ \ \ \ \"text\"\:\ p\.text\,\
\ \ \ \ \ \ \ \ \"created_at\"\:\ p\.created_at\.isoformat\(\)\,\
\ \ \ \ \ \ \ \ \"author\"\:\ \{\"id\"\:\ p\.author\.id\,\ \"username\"\:\ p\.author\.username\,\ \"created_at\"\:\ p\.author\.created_at\.isoformat\(\)\}\,\
\ \ \ \ \ \ \ \ \"likes\"\:\ int\(like_counts\.get\(p\.id\,\ 0\)\)\,\
\ \ \ \ \ \ \ \ \"liked_by_me\"\:\ liked_by_me\,\
\ \ \ \ \ \ \ \ \"comments_count\"\:\ int\(cc\)\,\
\ \ \ \ \}

@bp.get("")
def list_posts():
    cursor = request.args.get("cursor")
    try:
        limit = min(int(request.args.get("limit", 20)), 50)
    except Exception:
        limit = 20

    q = Post.query
    if cursor:
        try:
            ts_s, id_s = cursor.split("|")
            ts = datetime.fromisoformat(ts_s)
            q = q.filter(or_(Post.created_at < ts, and_(Post.created_at == ts, Post.id < int(id_s))))
        except Exception:
            return jsonify({"error": "bad cursor"}), 400

    items = q.order_by(Post.created_at.desc(), Post.id.desc()).limit(limit + 1).all()

    next_cursor = None
    if len(items) > limit:
        last = items[limit - 1]
        next_cursor = f"{last.created_at.isoformat()}|{last.id}"
        items = items[:limit]

    like_counts: dict[int, int] = {}
    liked_by_me_ids: set[int] = set()

    if items:
        post_ids = [p.id for p in items]

        # суммарные лайки
        rows = db.session.execute(
            db.select(Like.post_id, func.count(Like.id))
            .where(Like.post_id.in_(post_ids))
            .group_by(Like.post_id)
        ).all()
        for pid, cnt in rows:
            like_counts[int(pid)] = int(cnt)

        # liked_by_me (опционально читаем токен)
        try:
            verify_jwt_in_request(optional=True)
            ident = get_jwt_identity()
            uid = int(ident) if ident is not None else None
        except Exception:
            uid = None

        if uid:
            rows2 = db.session.execute(
                db.select(Like.post_id)
                .where(and_(Like.user_id == uid, Like.post_id.in_(post_ids)))
            ).scalars().all()
            liked_by_me_ids = {int(x) for x in rows2}

    return jsonify({"items": [_serialize_post(p, like_counts, liked_by_me_ids) for p in items], "next_cursor": next_cursor})

@bp.post("")
@jwt_required()
def create_post():
    uid = int(get_jwt_identity())
    user = User.query.get_or_404(uid)
    payload = request.get_json(force=True) or {}
    text = (payload.get("text") or "").strip()
    if not text:
        return jsonify({"error": "text required"}), 400
    if len(text) > 1000:
        return jsonify({"error": "text too long (1000 chars max)"}), 413
    post = Post(user_id=user.id, text=text)
    db.session.add(post)
    db.session.commit()
    return jsonify(_serialize_post(post, {})), 201

@bp.post("/<int:post_id>/like")
@jwt_required()
def like_post(post_id: int):
    uid = int(get_jwt_identity())
    if not Post.query.get(post_id):
        return jsonify({"error": "not found"}), 404
    exists = Like.query.filter_by(user_id=uid, post_id=post_id).first()
    if not exists:
        db.session.add(Like(user_id=uid, post_id=post_id))
        db.session.commit()
    return jsonify({"ok": True}), 201

@bp.delete("/<int:post_id>/like")
@jwt_required()
def unlike_post(post_id: int):
    uid = int(get_jwt_identity())
    like = Like.query.filter_by(user_id=uid, post_id=post_id).first()
    if like:
        db.session.delete(like)
        db.session.commit()
    return jsonify({"ok": True})

@bp.get("/<int:post_id>")
def get_post(post_id: int):
    cursor_uid = None
    try:
        cursor_uid = int(get_jwt_identity())
    except Exception:
        pass
    like_counts = {}
    post = Post.query.get_or_404(post_id)
    # likes count
    rows = db.session.execute(
        db.select(Like.post_id, func.count(Like.id)).where(Like.post_id == post.id).group_by(Like.post_id)
    ).all()
    for pid, cnt in rows:
        like_counts[int(pid)] = int(cnt)
    return jsonify(_serialize_post(post, like_counts, current_user_id=cursor_uid))

@bp.patch("/<int:post_id>")
@jwt_required()
def edit_post(post_id: int):
    uid = int(get_jwt_identity())
    post = Post.query.get_or_404(post_id)
    if post.user_id != uid:
        return jsonify({"error": "forbidden"}), 403
    payload = request.get_json(force=True) or {}
    text = (payload.get("text") or "").strip()
    if not text: return jsonify({"error":"text required"}), 400
    if len(text) > 1000: return jsonify({"error":"text too long"}), 413
    post.text = text
    db.session.commit()
    return jsonify({"ok": True})

@bp.delete("/<int:post_id>")
@jwt_required()
def delete_post(post_id: int):
    uid = int(get_jwt_identity())
    post = Post.query.get_or_404(post_id)
    if post.user_id != uid:
        return jsonify({"error": "forbidden"}), 403
    db.session.delete(post)
    db.session.commit()
    return jsonify({"ok": True})

# --- comments ---
@bp.get("/<int:post_id>/comments")
def list_comments(post_id: int):
    Post.query.get_or_404(post_id)
    items = db.session.execute(
        db.select(Comment).where(Comment.post_id == post_id).order_by(Comment.created_at.asc())
    ).scalars().all()
    return jsonify([{
        "id": c.id,
        "text": c.text,
        "created_at": c.created_at.isoformat(),
        "author": {"id": c.user.id, "username": c.user.username, "created_at": c.user.created_at.isoformat()},
    } for c in items])

@bp.post("/<int:post_id>/comments")
@jwt_required()
def create_comment(post_id: int):
    uid = int(get_jwt_identity())
    Post.query.get_or_404(post_id)
    payload = request.get_json(force=True) or {}
    text = (payload.get("text") or "").trim() if hasattr(str, "trim") else (payload.get("text") or "").strip()
    if not text: return jsonify({"error":"text required"}), 400
    if len(text) > 500: return jsonify({"error":"text too long (500)"}), 413
    c = Comment(user_id=uid, post_id=post_id, text=text)
    db.session.add(c); db.session.commit()
    return jsonify({"id": c.id}), 201

@bp.delete("/<int:post_id>/comments/<int:cid>")
@jwt_required()
def delete_comment(post_id: int, cid: int):
    uid = int(get_jwt_identity())
    c = Comment.query.get_or_404(cid)
    if c.post_id != post_id: return jsonify({"error":"not found"}), 404
    if c.user_id != uid: return jsonify({"error":"forbidden"}), 403
    db.session.delete(c); db.session.commit()
    return jsonify({"ok": True})
